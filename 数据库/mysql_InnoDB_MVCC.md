# 多版本并发控制
InnoDB存储引擎中用于实现高并发和事务隔离的机制。
通过再数据行上维护版本，允许事务进行并发读写。
# 版本号
会作为隐藏列存储，通常通过时间戳生成，用来实现MVCC。
每次修改数据（执行update）都会产生一个新的版本。
# 版本链
存储当前行的历史信息（数据值，事务ID，时间戳），用于维护回滚历史版本，每次数据更新时都会增加，定期purge。
通常版本链会比表本身还大。
删除只会置一个删除标记也定期purge。
按行存储是为了避免访问更加复杂，如果按列会每个列都有一个版本链。同时关系型数据库以行为基本单位。
每次有新版本时都会链接到版本链上。
回滚事务时InnDB会标记该事务创建的版本链失效或删除，然后再清理回收。
## 版本链如何避免过大
事务提交后定期回收旧版本。
也通过redo log记录操作。
太大需要考虑优化，分区拆表。
# 读视图
在使用MVCC的事务上会生成读视图，读视图包含当前事务的版本号，并记录当前时间戳作为事务启动时间，读视图创建不更新版本。
在一些实现中时间戳与版本号等同。
在读数据时会通过读视图进行。
## 读视图特别大的情况（表特别大的情况）
进行页级别管理，每个页对应一个读视图，访问到对应页时加载进内存，不加载整个表的读视图。
# 各个隔离级别使用情况
- 读未提交：不使用MVCC。（读直接最新版本，注意写会加锁）
- 读已提交：使用MVCC避免脏读。（每次读取都会检查以得到版本链上已经提交的最新版本）
- 可重复读：使用MVCC避免脏读和不可重复读。（每次读只会得到小于等于当前时间戳的数据或者本事务的版本链上的）
- 串行化： 严格事务隔离。
# 回滚
回滚的事务会将版本链对应的项进行标记，定时回收清理。
# MVCC总结
1. 通过版本标记行，并通过版本链进行多版本保存。
2. 事务开始时创建读视图，读视图有时间戳。
3. 每次数据更新时更新版本链。
4. 不同隔离级别数据可见性不同，控制主要通过版本链和读视图时间戳决定。
5. 回滚通过版本链进行
# MVCC幻读
混用加锁读（for update）会导致


